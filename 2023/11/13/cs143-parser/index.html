<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_s.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Compiler -- Parser">
<meta property="og:url" content="http://example.com/2023/11/13/cs143-parser/index.html">
<meta property="og:site_name" content="AjiL&#39;s Blog">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/paser_tree.png">
<meta property="og:image" content="http://example.com/img/cfg_ambiguity.png">
<meta property="og:image" content="http://example.com/img/AST.png">
<meta property="article:published_time" content="2023-11-13T02:34:59.000Z">
<meta property="article:modified_time" content="2024-08-03T12:36:17.507Z">
<meta property="article:author" content="AjiL">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/paser_tree.png">


<link rel="canonical" href="http://example.com/2023/11/13/cs143-parser/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"http://example.com/2023/11/13/cs143-parser/","path":"2023/11/13/cs143-parser/","title":"Compiler -- Parser"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Compiler -- Parser | AjiL's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">AjiL's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">上下文无关文法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">二义性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91"><span class="nav-number">4.</span> <span class="nav-text">语法制导翻译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">抽象语法树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">自顶而下解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92"><span class="nav-number">7.</span> <span class="nav-text">左递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E7%BA%A6%E5%88%86"><span class="nav-number">8.</span> <span class="nav-text">左约分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ll1%E8%A7%A3%E6%9E%90"><span class="nav-number">9.</span> <span class="nav-text">LL(1)解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#first-%E9%9B%86%E4%B8%8E-follow-%E9%9B%86"><span class="nav-number">10.</span> <span class="nav-text">first 集与 follow 集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="nav-number">11.</span> <span class="nav-text">错误恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A%E8%A7%A3%E6%9E%90"><span class="nav-number">12.</span> <span class="nav-text">自底而上解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84"><span class="nav-number">13.</span> <span class="nav-text">句柄</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B2%E7%AA%81"><span class="nav-number">14.</span> <span class="nav-text">冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lr0-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">15.</span> <span class="nav-text">LR(0) 自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slr-%E8%A7%A3%E6%9E%90"><span class="nav-number">16.</span> <span class="nav-text">SLR 解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lr1-%E8%A7%A3%E6%9E%90"><span class="nav-number">17.</span> <span class="nav-text">LR(1) 解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lalr-%E8%A7%A3%E6%9E%90"><span class="nav-number">18.</span> <span class="nav-text">LALR 解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab"><span class="nav-number">19.</span> <span class="nav-text">Lab</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AjiL"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AjiL</p>
  <div class="site-description" itemprop="description">El Psy Kongroo</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/XajilX" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XajilX" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://www.tonyjam.cn/" title="http:&#x2F;&#x2F;www.tonyjam.cn&#x2F;" rel="noopener" target="_blank">TonyJam</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://zmyjoe.github.io/" title="https:&#x2F;&#x2F;zmyjoe.github.io&#x2F;" rel="noopener" target="_blank">ZmyJoe</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://halc.top/" title="https:&#x2F;&#x2F;halc.top&#x2F;" rel="noopener" target="_blank">HalcyonAzu</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/cs143-parser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AjiL">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AjiL's Blog">
      <meta itemprop="description" content="El Psy Kongroo">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Compiler -- Parser | AjiL's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Compiler -- Parser
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-13 13:34:59" itemprop="dateCreated datePublished" datetime="2023-11-13T13:34:59+11:00">2023-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr />
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>语法分析将上一步生成的 token
流作为输入，通过定义的语法结构将其组织为<strong>解析树（parse
tree）</strong>或更精简的<strong>抽象语法树（Abstract Syntax tree, abbr.
AST）</strong>。由于语法分析器功能相较词法分析器更为强大，因此有些编译器可能会将词法分析的功能合并进语法分析器中。</p>
<p>虽然正则表达式被广泛用于各类字符串识别的场景，仍有相当一部分语言是无法用正则表达式表示的，例如括号的匹配和表达式的递归嵌套。因此需要一个更强大的工具来描述语法。在语法分析中通常使用<strong>上下文无关文法（Context-Free
Grammar, abbr. CFG）</strong>来描述语法。</p>
<h2 id="上下文无关文法">上下文无关文法</h2>
<p>CFG 通常包括以下四个部分：</p>
<ul>
<li>一组<strong>终止符（terminals）</strong>，通常和 token
是一一对应的；</li>
<li>一组<strong>非终止符（non-terminals）</strong>，通常一个非终止符代表了一个语法结构；</li>
<li>一个<strong>起始符</strong>，通常用<span
class="math inline">\(S\)</span>表示，属于非终止符；</li>
<li>一组<strong>产生式（productions）</strong>，每个产生式包含一个箭头，左边是一个非终止符，右边是一个包含终止符或非终止符的一个序列。</li>
</ul>
<p>为了方便书写，通常会将同一个非终止符为左式的产生式组织到一起，使用<code>|</code>将不同的右式分隔开来。例如对于一个仅包含加减法的算式，可以使用如下
CFG 描述（为方便起见这里的数字都只有一位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  S + dig</span><br><span class="line">     |  S - dig</span><br><span class="line">     |  dig</span><br><span class="line">dig -&gt;  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure>
<p>对于一个 CFG，可以执行以下步骤：</p>
<ol type="1">
<li>从仅包含一个起始符<span
class="math inline">\(S\)</span>的串开始；</li>
<li>将任意一个串中的非终止符使用任意的以其为左式的产生式将其替换为产生式右边的串；</li>
<li>重复步骤 2 直至串中没有非终止符为止。</li>
</ol>
<p>通过该步骤生成的所有串对应的 token 串即为该 CFG
接受的串，这个过程也被称为<strong>推导（derivation）</strong>。</p>
<p>推导的过程可以用树来表示。例如对于一个非终止符<span
class="math inline">\(A\)</span>，如果有产生式<span
class="math inline">\(A \to
XYZ\)</span>，使用该产生式的推导过程可以用如下的树来表示：</p>
<figure>
<img src="/img/paser_tree.png" alt="解析树" />
<figcaption aria-hidden="true">解析树</figcaption>
</figure>
<p>这样生成的树就叫做<strong>解析树</strong>。语法分析的目标便是分析给定的
token 串是否能被给定的 CFG 接受，并对接受的 token
串使用解析树来揭示其语法结构并进行处理。</p>
<p>解析树有以下特征：</p>
<ul>
<li>树的根结点为起始符；</li>
<li>树的叶结点均为终止符（或者是空串符号<span
class="math inline">\(\epsilon\)</span>），非叶结点都是非终止符；</li>
<li>若某个非叶结点<span
class="math inline">\(A\)</span>从左到右（注意顺序很重要）有子结点<span
class="math inline">\(X_1, X_2, \cdots, X_n\)</span>，则说明 CFG
有产生式<span class="math inline">\(A \to X_1X_2 \cdots
X_n\)</span>；</li>
<li>所有叶结点从左往右遍历即为原 token 串。</li>
</ul>
<p>一个解析树可能由不同的推导过程而来，这主要是因为非终止符的展开顺序不同。最重要的两个是最左推导（left-most
derivation）与最右推导（right-most
derivation）。后面可以看到这两种推导顺序对应了两类不同的解析算法。</p>
<h2 id="二义性">二义性</h2>
<p>以之前所描述的仅包含加减法算式的 CFG
为例，如果没有对数字和算式进行区分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  S + S</span><br><span class="line">     |  S - S</span><br><span class="line">     |  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure>
<p>对算式<code>9-5+2</code>进行推导，可能生成两种不同的解析树：</p>
<figure>
<img src="/img/cfg_ambiguity.png" alt="二义性" />
<figcaption aria-hidden="true">二义性</figcaption>
</figure>
<p>这种情况意味着语法中有歧义（ambiguity），因为两种解析树通常意味着同一个串的不同含义，可能会导致不确定的行为，因此需要消歧。</p>
<p>其中一种办法是手动重写语法使其不带歧义，例如之前定义的语法将数字与算式分开，这样将会生成类似与左边的解析树。另外一种办法是指定运算符的<strong>结合性（associativity）</strong>与<strong>优先级（precedence）</strong>，例如指定加法与减法均为左结合则会生成左边的解析树，指定加法优先级大于减法则会生成右边的解析树。</p>
<h2 id="语法制导翻译">语法制导翻译</h2>
<p>通过在产生式的中间加入一些程序片段，我们可以利用解析树的结构来达成一些事情。例如，通过添加程序片段，下面的产生式将输出算式的后缀表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  S + dig &#123; print(&#x27;+&#x27;) &#125;</span><br><span class="line">     |  S - dig &#123; print(&#x27;-&#x27;) &#125;</span><br><span class="line">     |  dig</span><br><span class="line">dig -&gt;  0 &#123; print(&#x27;0&#x27;) &#125;</span><br><span class="line">     |  1 &#123; print(&#x27;1&#x27;) &#125;</span><br><span class="line">     |  2 &#123; print(&#x27;2&#x27;) &#125;</span><br><span class="line">     |  ...</span><br></pre></td></tr></table></figure>
<p>这类在产生式中添加程序片段的 CFG
被称为<strong>语法制导翻译（Syntax-directed
translation）</strong>；其中的程序片段通常被大括号包裹起来，被称为<strong>语义动作（semantic
actions）</strong>。有时解析树中的结点会带有“返回值”，这些“返回值”被称为结点的属性（attribute）。</p>
<p>语法制导翻译并不需要建立解析树，只需要逻辑上按照<strong>后序遍历</strong>的顺序遍历解析树结点并执行其中的程序片段即可。也因此语法制导翻译可以用于建立解析树本身，但更通常的做法是建立<strong>抽象语法树</strong>。</p>
<h2 id="抽象语法树">抽象语法树</h2>
<p>抽象语法树有时也简称为语法树。对于一个表达式，其抽象语法树（AST）的根结点代表了一个运算（operation），根的子结点代表了该运算的被操作树。例如对于上面的例子，生成的
AST 如下所示：</p>
<figure>
<img src="/img/AST.png" alt="AST" />
<figcaption aria-hidden="true">AST</figcaption>
</figure>
<p>一般对于编程语言，所有语法结构基本都可以用运算与被操作数的结构来表示，因此总是可以建立
AST 来分析其中的语法与语义。</p>
<p>相较于解析树，AST
丢弃了一些仅有语法意义的“助记符”，例如代表加号、括号的终止符等。相对于“抽象”，解析树有时也被称为“具体语法树”（concrete
syntax tree）。</p>
<h2 id="自顶而下解析">自顶而下解析</h2>
<p><strong>自顶而下解析（top-down
parsing）</strong>也称递归下降解析（recursive decent
parsing），是最简单的一种解析方法，具体步骤如下：</p>
<ol type="1">
<li>首先初始化一个全局的<code>next</code>指针，指向 token 串的第一个
token 。然后调用一个与起始符<span
class="math inline">\(S\)</span>有关的函数<code>S()</code>；</li>
<li>对于非终止符<span
class="math inline">\(E\)</span>，定义与其相关的函数<code>E()</code>，记录下调用时<code>next</code>指针的位置，对<span
class="math inline">\(E\)</span>的所有产生式依次检查 token
串是否符合该产生式，每次检查前将<code>next</code>指针重置；</li>
<li>对于终止符<span
class="math inline">\(t\)</span>，定义与其相关的函数<code>t()</code>，若当前<code>next</code>指针指向的
token 与终止符对应的 token
一致则返回<code>true</code>并将<code>next</code>指针前移一位；否则返回<code>false</code>；</li>
<li>对于每个产生式，依次调用右侧串符号对应的函数，若中间有函数返回<code>false</code>则返回<code>false</code>，否则返回<code>true</code>。</li>
</ol>
<p>可以看出对于每个产生式，自顶而下解析算法都是从左到右依次展开的，所以生成的推导是<strong>最左推导</strong>。</p>
<h2 id="左递归">左递归</h2>
<p>自顶而下解析并不适用于所有的 CFG，一个简单的例子是之前所定义的
CFG：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  S + dig</span><br><span class="line">     |  S - dig</span><br><span class="line">     |  dig</span><br><span class="line">dig -&gt;  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure>
<p>如果对该 CFG 使用自顶而下解析，则可能一直对非终止符<span
class="math inline">\(S\)</span>进行解析，导致无限递归。这种现象被称为<strong>左递归（Left
Recursion）</strong>。消除左递归的方式是重写语法，例如如上的 CFG
可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  dig S&#x27;</span><br><span class="line">S&#x27;  -&gt;  + dig S&#x27;</span><br><span class="line">     |  - dig S&#x27;</span><br><span class="line">     |  /*epsilon*/</span><br><span class="line">dig -&gt;  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure>
<p>中间的<code>epsilon</code>用注释包起来了，这一行的意思是该非终止符接受空串。</p>
<p>另一种形式的左递归如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  Aa | b</span><br><span class="line">A   -&gt;  Sc</span><br></pre></td></tr></table></figure>
<p>这种非直接的左递归可以规约到直接的左递归语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  Aa | b</span><br><span class="line">A   -&gt;  Aac | bc</span><br></pre></td></tr></table></figure>
<p>理论上所有的左递归语法都可以通过重写来得到等价的消除左递归语法，可以使用算法来自动消除左递归，但由于语法中可能存在语义动作，因此多数时候消除左递归是手动实现的。</p>
<h2 id="左约分">左约分</h2>
<p>另一种使用自顶而下解析算法可能产生的问题如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  a | abS</span><br></pre></td></tr></table></figure>
<p>当遇到像<code>aba</code>这样的串时可能会提前返回从而导致解析失败。解决该问题的方法同样是重写语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S   -&gt;  aS&#x27;</span><br><span class="line">S&#x27;  -&gt;  bS | /*epsilon*/</span><br></pre></td></tr></table></figure>
<p>这种重写将相同左子串的多个产生式缩为一个产生式，称为<strong>左约分（left-factor）</strong>。</p>
<p>左约分同样可以使用算法自动处理，但基于相同的原因，多数时候消除左约分也是手动实现的。</p>
<h2 id="ll1解析">LL(1)解析</h2>
<p>经过消除左递归与左约分，绝大多数语法都可以进行<strong>预测解析（predictive
parsing）</strong>，即可以根据一部分输入的 token
与当前的解析树结点来确定当前应该执行的产生式。例如对于上面已经消除左递归的算式语法，可以建立如下的表格（这里将<code>dig</code>直接视为字符）：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>dig</th>
<th>+</th>
<th>-</th>
<th>$</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S</td>
<td><code>dig S'</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>S’</td>
<td></td>
<td><code>+ dig S'</code></td>
<td><code>- dig S'</code></td>
<td><code>/*epsilon*/</code></td>
</tr>
</tbody>
</table>
<p>该表行头一个非终止符，列头为一个
token，行列交界代表当处理某非终止符时遇到下一个 token
应该使用哪个产生式，<code>$</code>代表输入结束，空单元格代表该搭配不在语法中，是错误搭配。</p>
<p>像这样只使用一个 token
进行预测的称为<strong>LL(1)解析</strong>，如上的表称为<strong>LL(1)解析表</strong>，能够使用LL(1)解析的语法称为<strong>LL(1)语法</strong>。“LL(1)”中第一个“L”代表
token 串从左往右扫描（Left to right），第二个“L”代表最左推导（Leftmost
derivation），括号中的“1”代表仅使用一个输入 token 进行预测解析。</p>
<h2 id="first-集与-follow-集">first 集与 follow 集</h2>
<p>为了构建解析表，需要计算每个非终止符的 <strong>first 集</strong>与
<strong>follow 集</strong>。</p>
<p>first 集（用小写<span
class="math inline">\(f\)</span>表示）定义如下：</p>
<p><span class="math display">\[f(A) = \{t \mid A \to^* t\beta\} \cup
\{\epsilon \mid A \to^* \epsilon\}\]</span></p>
<p>其中<span
class="math inline">\(t\)</span>为终止符，这个定义的意思即为若非终止符<span
class="math inline">\(A\)</span>可以推导出以<span
class="math inline">\(t\)</span>开头的串则<span class="math inline">\(t
\in f(A)\)</span>，当<span
class="math inline">\(A\)</span>可以推导出空串则<span
class="math inline">\(\epsilon \in f(A)\)</span>。</p>
<p>对于<span class="math inline">\(f(A)\)</span>，有：</p>
<p><span class="math display">\[
\begin{cases}
t \in T \Rightarrow f(t) = \{t\} \\
\begin{cases}
\exists A \to C\beta  \\
\exists A \to B_1\cdots B_nC, \forall 1 \leq i\leq n, \epsilon \in
f(B_i)
\end{cases}
&amp; \Rightarrow f(C) \subseteq f(A) \\
\begin{cases}
\exists A \to \epsilon  \\
\exists A \to B_1\cdots B_n, \forall 1 \leq i\leq n, \epsilon \in f(B_i)
\end{cases}
&amp; \Rightarrow \epsilon \in f(A)
\end{cases}
\]</span></p>
<p>其中大写的<span
class="math inline">\(T\)</span>代表终止符集合。利用这些定理可以计算出
first 集。</p>
<p>follow 集（用大写<span
class="math inline">\(F\)</span>表示）定义如下：</p>
<p><span class="math display">\[F(A) = \{t \mid S \to^* \beta At\gamma
\}\]</span></p>
<p>这个定义的意思即为，若<span class="math inline">\(t \in
F(A)\)</span>，当且仅当从起始符<span
class="math inline">\(S\)</span>可以推导出一个串，串中<span
class="math inline">\(t\)</span>出现在<span
class="math inline">\(A\)</span>的正后方。一个与 first
集定义的区别是<span class="math inline">\(\epsilon \notin
F(A)\)</span>。</p>
<p>对于<span class="math inline">\(F(A)\)</span>，有：</p>
<p><span class="math display">\[
\begin{cases}
\$ \in F(S) \\
\exists B \to \beta AC \Rightarrow (f(C)-\{\epsilon\}) \subseteq F(A) \\
\exists (B \to \beta AC \land \epsilon \in f(C)) \Rightarrow F(B)
\subseteq F(A) \\
\end{cases}
\]</span></p>
<p>其中美元符$表示串终止符号。</p>
<p>有了这两个集合便可以构建预测解析表。令<span
class="math inline">\(M[A, t]\)</span>表示解析表<span
class="math inline">\(A\)</span>行<span
class="math inline">\(t\)</span>列的项，对于每个产生式<span
class="math inline">\(A\to\alpha\)</span>，做如下操作：</p>
<ul>
<li><span class="math inline">\(\forall a \in f(\alpha)(a \neq
\epsilon), M[A, a] = \alpha\)</span></li>
<li><span class="math inline">\(\epsilon \in f(\alpha) \Rightarrow
\forall b \in F(A), M[A, b] = \alpha\)</span></li>
</ul>
<p>若其中发生冲突则需要增加预测符数量，变为LL(k)(k &gt; 1)语法。</p>
<h2 id="错误恢复">错误恢复</h2>
<p>有时我们希望编译器不要在只发现一个错误时就停下来，希望它尽可能地发现代码中的错误，因此需要编译器具有<strong>错误恢复（error
recovery）</strong>的能力。</p>
<p>对于现代的编译器，通常有两种方法实现错误恢复：<strong>惊慌模式（panic
mode）</strong>与<strong>错误产生式（error production）</strong>。</p>
<p>当使用惊慌模式遇到错误时，解析器会丢弃输入中的
token，直至遇到一个同步 token （synchronizing
token），此时解析解析器得以从错误中恢复。一个常见的案例是指定语句的结束符号（例如分号）作为同步
token，这样当语句中出现错误时不会影响到后续语句的解析。</p>
<p>错误产生式则是直接为某些常见错误添加对应的产生式，例如初学者经常将 C
语言中的<code>5 * x</code>写为<code>5 x</code>。
这样做的优点是可以根据指定的错误生成修复提示或直接修复错误，缺点是添加这类产生式将会使语法更难维护。</p>
<h2 id="自底而上解析">自底而上解析</h2>
<p>不同于自顶而下解析，<strong>自底而上解析（bottom-up
parsing）</strong>从叶结点开始向上构建解析树，通过<strong>规约（reduce）</strong>操作逆着产生式的方向将多个符号变为一个非终止符，最终规约到起始符。</p>
<p>通常来讲，自底而上解析能够适应的语法比自顶而下解析更多，但算法也更复杂，大多数时候自顶而下解析是手写的，而自底而上解析是由工具生成的，常见的工具有
yacc、 bison 等。</p>
<p>因此，如果我们从左到右扫描进行解析，则自底而上解析构建解析树的过程是逆向的<strong>最右推导</strong>，也因此这类解析称为
LR 解析。</p>
<p>对于该结论有一个重要的推论：假设在解析过程中生成了串<span
class="math inline">\(\alpha \beta
\omega\)</span>，且下一步规约依照产生式<span class="math inline">\(A \to
\beta\)</span>，则串<span
class="math inline">\(\omega\)</span>中<strong>只存在终止符</strong>。因为如果将规约过程倒过来，<span
class="math inline">\(\alpha A \omega \to \alpha \beta
\omega\)</span>是最右推导中的一个步骤。</p>
<p>如果我们将符号串用竖线隔开，其左侧包含终止符与已规约的非终止符，右侧为尚未检测的终止符串，则可以通过如下两个操作进行解析：</p>
<ul>
<li><strong>移位（shift）</strong>：将竖线往右移动一位（<span
class="math inline">\(\alpha\mid\beta\omega\Rightarrow\alpha\beta\mid\omega\)</span>）；</li>
<li><strong>规约（reduce）</strong>：若竖线左侧的右端子串符合要求则将其规约（<span
class="math inline">\(\alpha\beta\mid\omega\Rightarrow\alpha A
\mid\omega\)</span>）。</li>
</ul>
<p>这类解析方法也称作移位-规约解析（shift-reduce
parsing）。可以看出竖线左侧其实是一个栈。</p>
<h2 id="句柄">句柄</h2>
<p>要进行移位-规约解析，首先需要解决何时该进行规约的问题。一个朴素的想法是只进行那些能够最终规约到起始符的规约。</p>
<p>对于一个最右推导：</p>
<p><span class="math display">\[S \to^* \alpha A \omega \to \alpha \beta
\omega\]</span></p>
<p>则称产生式<span class="math inline">\(A \to \beta\)</span>与<span
class="math inline">\(\alpha\)</span>（或称串<span
class="math inline">\(\alpha\beta\)</span>）为串<span
class="math inline">\(\alpha\beta\omega\)</span>的一个<strong>句柄（handle）</strong>。如果语法为有歧义的语法，则最右推导不止一个，一个串可能有多个句柄。</p>
<p>对于移位规约解析，由于产生的推导是最右推导，因此当进行了规约操作后，另一个句柄要么在栈顶（对应规约），要么需要右侧未检测的终止符（对应移位），因此<strong>句柄只会出现在栈顶</strong>，也因此规约也只应该在栈顶进行，分割的竖线不会向左侧移动。</p>
<h2 id="冲突">冲突</h2>
<p>一部分语法是不能使用移位-规约解析的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S    -&gt;   Sa | Sab | Sb | a</span><br></pre></td></tr></table></figure>
<p>当遇到<span class="math inline">\(Sa \mid
b\)</span>的情形时，移位和规约都可以产生有效的解析。像这样的情形称为<strong>移位/规约冲突（shift/reduce
conflict）</strong>。</p>
<p>另一类冲突如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S    -&gt;   Sa | SE | a</span><br><span class="line">E    -&gt;   a | b</span><br></pre></td></tr></table></figure>
<p>当遇到<span class="math inline">\(Sa \mid
b\)</span>的情形时，两种不同的规约方式都可以产生有效的解析。像这样的情形称为<strong>规约/规约冲突（reduce/reduce
conflict）</strong>。</p>
<p>通常来讲，这类冲突是由于语法当中的歧义所导致的，需要通过重写语法或设定运算结合性和优先级来解决。通常移位/规约冲突比规约/规约冲突更好解决。例如一个简单的解决方法就是当遇到移位/规约冲突时总是使用移位。</p>
<h2 id="lr0-自动机">LR(0) 自动机</h2>
<p>虽然前面说明了句柄是什么以及句柄如何解决何时规约的问题，但并没有说明如何寻找句柄。为此需要定义<strong>可行前缀（viable
prefix）</strong>的概念：</p>
<p>对于一个符号串<span
class="math inline">\(\alpha\)</span>，若存在串<span
class="math inline">\(\omega\)</span>，<span
class="math inline">\(\alpha\mid\omega\)</span>为移位规约解析中的一个状态，则称<span
class="math inline">\(\alpha\)</span>为可行前缀。</p>
<p>称这个串为“可行的”是因为根据定义，可行前缀是<strong>句柄的一个前缀</strong>，也即只要当栈中的串为可行前缀，则总是有可能通过移位和规约得到句柄，从而成功解析。</p>
<p>对于可行前缀有一个重要结论：<strong>对于所有语法，可行前缀可以构成一个正则语言。</strong></p>
<p>为了证明这个结论，需要定义 <strong>LR(0) 项（LR(0)
item）</strong>（或简称项（item））：</p>
<p>一个 LR(0) 项是语法中一个产生式的某个前缀。</p>
<p>通常会使用<span
class="math inline">\(\cdot\)</span>分割产生式来表示一个项，例如对于一个产生式<span
class="math inline">\(A \to XYZ\)</span>，有四个 LR(0) 项：</p>
<p><span class="math display">\[\begin{aligned}
A \to &amp; \cdot XYZ \\
A \to &amp; X\cdot YZ \\
A \to &amp; XY\cdot Z \\
A \to &amp; XYZ\cdot  \\
\end{aligned}\]</span></p>
<p>特殊地，对于空串产生式<span
class="math inline">\(A\to\epsilon\)</span>只有一个项：<span
class="math inline">\(A\to \cdot\)</span></p>
<p>在移位规约解析的过程中，栈中存储着许多不同的产生式前缀，形如：</p>
<p><span class="math display">\[p_1p_2 \cdots p_n\]</span></p>
<p>令<span class="math inline">\(p_i\)</span>代表产生式<span
class="math inline">\(A_i \to \beta_i\)</span>的前缀，则：</p>
<ul>
<li><span class="math inline">\(p_i\)</span>最终将规约为<span
class="math inline">\(A_i\)</span>；</li>
<li><span class="math inline">\(p_{i-1}\)</span>的剩余部分由<span
class="math inline">\(A_i\)</span>开始；</li>
</ul>
<p>也即事实上可行前缀由若干的项组成，因此可以以项为状态，通过以下方式构建识别可行前缀的
NFA ：</p>
<ol type="1">
<li>添加一条生成原来的起始符的产生式<span
class="math inline">\(S&#39;\to S\)</span>；</li>
<li>对于每个形如<span class="math inline">\(A\to \alpha \cdot
B\beta\)</span>的项，添加一条边： <span class="math display">\[ (A \to
\alpha \cdot B\beta) \to^B (A \to \alpha B\cdot\beta) \]</span></li>
<li>对于对于每个形如<span class="math inline">\(A\to \alpha \cdot
B\beta\)</span>的项与产生式<span
class="math inline">\(B\to\gamma\)</span>，添加一条边： <span
class="math display">\[ (A \to \alpha \cdot B\beta) \to^\epsilon
(B\to\cdot\gamma) \]</span></li>
<li>对于该 NFA，其初始状态为<span class="math inline">\(S&#39;\to\cdot
S\)</span>，每个状态均为接受状态。</li>
</ol>
<p>将其转化为 DFA 后，其中的每个 NFA 状态集合称为项的典范集（canonical
collection of items），该 DFA 状态机称为 <strong>LR(0) 自动机（LR(0)
automaton）</strong>。</p>
<p>对于自动机的构造，我们只需关心 DFA
结点中称为<strong>核（kernel）</strong>的那些项，也即起始项<span
class="math inline">\(S&#39;\to \cdot S\)</span>还有那些分割符<span
class="math inline">\(\cdot\)</span>不在最左侧的项，因为显然其它的项是由
NFA <span
class="math inline">\(\epsilon\)</span>规约而来。通过只存储核可以缩减
LR(0) 自动机的内存占用。</p>
<p>使用 LR(0)
自动机可以很方便地判断栈中的串是否为可行前缀，只需要使用栈中的串在自动机中遍历一遍即可。最终停下的状态代表栈顶可能的项。</p>
<h2 id="slr-解析">SLR 解析</h2>
<p><strong>SLR 解析（Simple LR Parsing）</strong>使用 LR(0)
自动机，通过较为简单的规则来确定何时规约何时移位。</p>
<p>假设当前栈顶所在的 DFA 状态为<span
class="math inline">\(s\)</span>，下个输入的终止符为<span
class="math inline">\(t\)</span>， SLR 解析的规则为：</p>
<ul>
<li>当项<span class="math inline">\((A \to \alpha \cdot) \in
s\)</span>且<span class="math inline">\(t\in F(A)\)</span>（大写<span
class="math inline">\(F\)</span>代表 Follow 集）时使用<span
class="math inline">\(A \to \alpha\)</span>进行规约；</li>
<li>当项<span class="math inline">\((A \to \alpha \cdot t \omega) \in
s\)</span>时进行移位；</li>
<li>若输入结束时项<span class="math inline">\((S&#39; \to S\cdot )\in
s\)</span>，则接受该串；</li>
<li>若无法进行操作则报告错误。</li>
</ul>
<p>同样的，如果某语法在 SLR 解析下没有冲突，则该语法属于 SLR
语法，否则不属于。</p>
<h2 id="lr1-解析">LR(1) 解析</h2>
<p>在 SLR
解析中，我们做了一个“启发式”的假设，即当遇到的下一个符号属于规约产生式左项的
Follow 集时使用规约。但实际上有些语法并不一定适用这条假设。</p>
<p>解决这个问题的方法之一是我们对每个可能符号分别处理，在项中增加一个符号属性，当需要规约时检查该符号，如果与符号不匹配则不进行该规约。</p>
<p>像这样形如<span class="math inline">\([A\to\alpha\cdot\omega,
a]\)</span>的项称为 <strong>LR(1) 项</strong>。同样地，其中的 1
即代表项中的预测字符只有一个。</p>
<p>需要注意的是对于分割符<span
class="math inline">\(\cdot\)</span>不在最右侧的项来说，预测符是没有作用的。</p>
<p>创建 LR(1) 自动机只需要在创建 LR(0) 自动机的步骤中稍加改动即可：</p>
<ul>
<li>对于每个形如<span class="math inline">\([A\to \alpha \cdot B\beta,
a]\)</span>的项，添加一条边： <span class="math display">\[ [A \to
\alpha \cdot B\beta , a] \to^B [A \to \alpha B\cdot\beta , a]
\]</span></li>
<li>对于对于每个形如<span class="math inline">\([A\to \alpha \cdot
B\beta,a]\)</span>的项与产生式<span
class="math inline">\(B\to\gamma\)</span>，对于串<span
class="math inline">\(\beta a\)</span>的 first 集中的所有元素<span
class="math inline">\(b\in f(\beta a)\)</span>，添加一条边： <span
class="math display">\[ [A \to \alpha \cdot B\beta , a] \to^\epsilon
[B\to\cdot\gamma , b] \]</span></li>
<li>对于该 NFA，其初始状态为<span class="math inline">\([S&#39;\to\cdot
S , \$]\)</span>，每个状态均为接受状态；</li>
<li>将该 NFA 转为 DFA 即为 LR(1) 自动机。</li>
</ul>
<p>同样地，DFA 状态中包含的 LR(1) 项集称为 LR(1) 项典范集；使用 LR(1)
自动机进行的解析称为 <strong>LR(1) 解析</strong>或者叫<strong>典范 LR(1)
解析</strong>。假设当前栈顶所在的 DFA 状态为<span
class="math inline">\(s\)</span>，下个输入的终止符为<span
class="math inline">\(t\)</span>，其规则如下：</p>
<ul>
<li>当项<span class="math inline">\([A \to \alpha \cdot , t] \in
s\)</span>时使用<span class="math inline">\(A \to
\alpha\)</span>进行规约；</li>
<li>当项<span class="math inline">\([A \to \alpha \cdot t \omega , b]
\in s\)</span>时进行移位，其中的<span
class="math inline">\(b\)</span>为任意符号；</li>
<li>若输入结束时项<span class="math inline">\([S&#39; \to S\cdot, \$]\in
s\)</span>，则接受该串；</li>
<li>若无法进行操作则报告错误。</li>
</ul>
<h2 id="lalr-解析">LALR 解析</h2>
<p>通常来讲 LR(1) 自动机的状态数量较大，不适合工程上使用，于是就有了
<strong>LALR 解析（LookAhead-LR parsing）</strong>。</p>
<p>相比于 SLR，LALR 自动机的状态数量与 SLR
相同，但能够解析更多的语法；相比于 LR(1)，LALR
自动机的状态要少得多，能够解析的语法虽有缩减但能够满足绝大部分需要。因此
LALR 解析被广泛应用于各类自动工具中，如 yacc 和 bison。</p>
<p>通常，LR(1) 自动机中会包含许多“核心（core）”，即 LR(1) 项的前面的
LR(0) 项部分相同的结点，一个想法是把这些结点合并起来。因为 LR(1)
自动机的边只与项中的“核心”有关（<span
class="math inline">\(\epsilon\)</span>边转化为 DFA
后被去掉了），因此合并后之前连接的边也会合并。同时根据 LR(1)
自动机的构造规则，一个结点的“核心”与 LR(0) 自动机结点一一对应，因此 LALR
自动机的结点数量与 LR(0) 自动机相同且一一对应。</p>
<p>可以证明合并合并后的不会出现新的移位/规约冲突：合并后如果有出现移位/规约冲突则说明某个自动机结点内有项<span
class="math inline">\([A \to \alpha \cdot , a]\)</span>与<span
class="math inline">\([B \to \beta\cdot a\gamma ,
b]\)</span>。由于合并只会合并“核心”相同的结点，则在原先的 LR(1)
自动机中，项<span class="math inline">\([A \to \alpha \cdot ,
a]\)</span>所在的结点内必然有一个项<span class="math inline">\([B \to
\beta\cdot a\gamma , c]\)</span>，说明原来的 LR(1)
解析中具有相同的移位规约冲突。</p>
<p>但需要注意的是合并为 LALR 自动机后可能会出现新的规约/规约冲突，因此
LALR 语法是 LR(1) 语法的一个子集。</p>
<p>事实上生成 LALR 自动机并不需要真的合并 LR(1)
自动机的结点。通过之前的推导，我们可以通过扩展 LR(0)
自动机的方式，将预测符附在其中的 LR(0) 项上即可。同时根据之前的对 LR(0)
自动机的研究，这里只考虑对核附上预测符。</p>
<p>对于一个核项，有两种方式生成预测符：</p>
<ul>
<li>自发：对于核项<span class="math inline">\([A\to\alpha\cdot\beta,
a]\)</span>，其所在的 LR(1) 自动机结点后继存在项<span
class="math inline">\([B\to\gamma\cdot\delta, b]\)</span>，且<span
class="math inline">\(b\)</span>与<span
class="math inline">\(a\)</span>无关，则称<span
class="math inline">\(b\)</span>是由项<span
class="math inline">\(B\to\gamma\cdot\delta\)</span><strong>自发生成的（generated
spontaneously）</strong>；特别地，预测符<span
class="math inline">\(\$\)</span>（输入终止符）由项<span
class="math inline">\(S&#39;\to\cdot S\)</span>自发生成。</li>
<li>传播：同样对于核项<span class="math inline">\([A\to\alpha\cdot\beta,
a]\)</span>，其所在的 LR(1) 自动机结点后继存在项<span
class="math inline">\([B\to\gamma\cdot\delta, b]\)</span>，但<span
class="math inline">\(a=b\)</span>，其后继存在预测符<span
class="math inline">\(b\)</span>仅因为项<span
class="math inline">\(A\to\alpha\cdot\beta\)</span>也存在<span
class="math inline">\(b\)</span>作为附加的预测符。此时称预测符由<span
class="math inline">\(A\to\alpha\cdot\beta\)</span><strong>传播（propagate）</strong>至<span
class="math inline">\(B\to\gamma\cdot\delta\)</span>。注意传播本身与预测符无关，如果一个项传播至另一个项则其所有预测符均将附在被传播的项上。</li>
</ul>
<p>事实上可以发现，两种生成方式的不同是由于 LR(1)
自动机生成规则中生成<span
class="math inline">\(\epsilon\)</span>边的规则导致的，串<span
class="math inline">\(\beta
a\)</span>的不同情况导致了不同的生成方式：若<span
class="math inline">\(\epsilon\in f(\beta)\)</span>，则<span
class="math inline">\(a\in f(\beta
a)\)</span>，此时便会产生传播；同时<span class="math inline">\(f(\beta)
\subseteq f(\beta a)\)</span>，此时<span
class="math inline">\(f(\beta)\)</span>的部分便是自发生成的预测符。</p>
<p>由于传播行为本身与预测符无关，因此我们可以使用一个不在语法中的终止符<span
class="math inline">\(\\#\)</span>来分辨两种生成方式，具体来说：</p>
<ol type="1">
<li>对核项<span class="math inline">\([A\to\alpha\cdot\beta,
\\#]\)</span>使用 LR(1) 自动机的生成规则生成其<span
class="math inline">\(\epsilon\)</span>闭包（也即只使用<span
class="math inline">\(\epsilon\)</span>边能到达的 LR(1) 项）；</li>
<li>若项<span class="math inline">\([B\to\gamma\cdot X\delta, a],
a\neq\\#\)</span>在闭包中，则在核项<span
class="math inline">\(A\to\alpha\cdot\beta\)</span>的<span
class="math inline">\(X\)</span>边的后继结点中，<span
class="math inline">\(a\)</span>是<span class="math inline">\(B\to\gamma
X\cdot\delta\)</span>自发生成的（注意分割符的位置）；</li>
<li>若项<span class="math inline">\([B\to\gamma\cdot X\delta,
\\#]\)</span>在闭包中，则在核项<span
class="math inline">\(A\to\alpha\cdot\beta\)</span>的<span
class="math inline">\(X\)</span>边的后继结点中，<span
class="math inline">\(A\to\alpha\cdot\beta\)</span>将预测符传播自<span
class="math inline">\(B\to\gamma X\cdot\delta\)</span>。</li>
</ol>
<p>最后使用两种附上预测符的方式将预测符附上即可建立 LALR 自动机：</p>
<ol type="1">
<li>生成 LR(0) 自动机以及其结点内的核；</li>
<li>使用上面的算法标记哪些预测符是自发生成，哪些项需要传播；</li>
<li>使用自发生成的预测符初始化核项；</li>
<li>传播预测符，直到最终没有新的预测符传播。</li>
</ol>
<h2 id="lab">Lab</h2>
<p>作业三需要使用 bison 生成 COOL 语言的 Parser。</p>
<p>首先需要定义各个非终止符所生成的 AST 类别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Declare types for the grammar&#x27;s non-terminals. */</span><br><span class="line">%type &lt;program&gt; program</span><br><span class="line">%type &lt;classes&gt; class_list</span><br><span class="line">%type &lt;class_&gt; class</span><br><span class="line"></span><br><span class="line">/* You will want to change the following line. */</span><br><span class="line">%type &lt;feature&gt; feature</span><br><span class="line">%type &lt;features&gt; feature_list</span><br><span class="line"></span><br><span class="line">%type &lt;formal&gt; param</span><br><span class="line">%type &lt;formals&gt; param_list</span><br><span class="line"></span><br><span class="line">%type &lt;case_&gt; case</span><br><span class="line">%type &lt;cases&gt; case_list</span><br><span class="line"></span><br><span class="line">%type &lt;expression&gt; expr</span><br><span class="line">%type &lt;expression&gt; closure_expr disp_expr bininv_expr isvoid_expr muldiv_expr addsub_expr comp_expr loginv_expr assign_expr let_expr let_rem_expr</span><br><span class="line">%type &lt;expressions&gt; block_expr_list aug_expr_list</span><br><span class="line"></span><br><span class="line">/* Precedence declarations go here. */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法按照手册中给出的 CFG 写就行，唯一需要注意的是在 bison
中需要使用<code>error</code>来指定惊慌模式与同步 token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">Save the root of the abstract syntax tree in a global variable.</span><br><span class="line">*/</span><br><span class="line">program    : class_list	&#123; @$ = @1; ast_root = program($1); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">class_list</span><br><span class="line">: class            /* single class */</span><br><span class="line">&#123; $$ = single_Classes($1);</span><br><span class="line">parse_results = $$; &#125;</span><br><span class="line">| class_list class    /* several classes */</span><br><span class="line">&#123; $$ = append_Classes($1,single_Classes($2)); </span><br><span class="line">parse_results = $$; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/* If no parent is specified, the class inherits from the Object class. */</span><br><span class="line">class    : CLASS TYPEID &#x27;&#123;&#x27; feature_list &#x27;&#125;&#x27; &#x27;;&#x27;</span><br><span class="line">&#123; $$ = class_($2,idtable.add_string(&quot;Object&quot;),$4,</span><br><span class="line">stringtable.add_string(curr_filename)); &#125;</span><br><span class="line">| CLASS TYPEID INHERITS TYPEID &#x27;&#123;&#x27; feature_list &#x27;&#125;&#x27; &#x27;;&#x27;</span><br><span class="line">&#123; $$ = class_($2,$4,$6,stringtable.add_string(curr_filename)); &#125;</span><br><span class="line">| CLASS error &#x27;;&#x27;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/* Feature list may be empty, but no empty features in list. */</span><br><span class="line">feature_list:        /* empty */</span><br><span class="line">&#123;  $$ = nil_Features(); &#125;</span><br><span class="line">| feature</span><br><span class="line">&#123; $$ = single_Features($1); &#125;</span><br><span class="line">| feature_list feature</span><br><span class="line">&#123; $$ = append_Features($1,single_Features($2)); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">feature    : OBJECTID &#x27;:&#x27; TYPEID &#x27;;&#x27;</span><br><span class="line">&#123; $$ = attr($1,$3,no_expr()); &#125;</span><br><span class="line">| OBJECTID &#x27;:&#x27; TYPEID ASSIGN expr &#x27;;&#x27;</span><br><span class="line">&#123; $$ = attr($1,$3,$5); &#125;</span><br><span class="line">| OBJECTID &#x27;(&#x27; param_list &#x27;)&#x27; &#x27;:&#x27; TYPEID &#x27;&#123;&#x27; expr &#x27;&#125;&#x27; &#x27;;&#x27;</span><br><span class="line">&#123; $$ = method($1,$3,$6,$8); &#125;</span><br><span class="line">| error &#x27;;&#x27;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">param    : OBJECTID &#x27;:&#x27; TYPEID &#123; $$ = formal($1,$3); &#125;;</span><br><span class="line">param_list    : 	</span><br><span class="line">&#123; $$ = nil_Formals(); &#125;</span><br><span class="line">| param</span><br><span class="line">&#123; $$ = single_Formals($1); &#125;</span><br><span class="line">| param_list &#x27;,&#x27; param</span><br><span class="line">&#123; $$ = append_Formals($1,single_Formals($3)); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">case    : OBJECTID &#x27;:&#x27; TYPEID DARROW expr &#x27;;&#x27;</span><br><span class="line">&#123; $$ = branch($1,$3,$5); &#125;</span><br><span class="line">;</span><br><span class="line">case_list    : case</span><br><span class="line">&#123; $$ = single_Cases($1); &#125;</span><br><span class="line">| case_list case</span><br><span class="line">&#123; $$ = append_Cases($1,single_Cases($2)); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr    : assign_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">| let_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">closure_expr: IF expr THEN expr ELSE expr FI</span><br><span class="line">&#123; $$ = cond($2,$4,$6); &#125;</span><br><span class="line">| WHILE expr LOOP expr POOL</span><br><span class="line">&#123; $$ = loop($2,$4); &#125;</span><br><span class="line">| CASE expr OF case_list ESAC</span><br><span class="line">&#123; $$ = typcase($2,$4); &#125;</span><br><span class="line">| NEW TYPEID</span><br><span class="line">&#123; $$ = new_($2); &#125;</span><br><span class="line">| OBJECTID</span><br><span class="line">&#123; $$ = object($1); &#125;</span><br><span class="line">| &#x27;&#123;&#x27; block_expr_list &#x27;&#125;&#x27;</span><br><span class="line">&#123; $$ = block($2); &#125;</span><br><span class="line">| &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">&#123; $$ = $2; &#125;</span><br><span class="line">| BOOL_CONST</span><br><span class="line">&#123; $$ = bool_const($1); &#125;</span><br><span class="line">| INT_CONST</span><br><span class="line">&#123; $$ = int_const($1); &#125;</span><br><span class="line">| STR_CONST</span><br><span class="line">&#123; $$ = string_const($1); &#125;</span><br><span class="line">| OBJECTID &#x27;(&#x27; aug_expr_list &#x27;)&#x27;</span><br><span class="line">&#123; $$ = dispatch(object(idtable.add_string(&quot;self&quot;)),$1,$3); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">disp_expr    : closure_expr &#x27;.&#x27; OBJECTID &#x27;(&#x27; aug_expr_list &#x27;)&#x27;</span><br><span class="line">&#123; $$ = dispatch($1,$3,$5); &#125;</span><br><span class="line">| closure_expr &#x27;@&#x27; TYPEID &#x27;.&#x27; OBJECTID &#x27;(&#x27; aug_expr_list &#x27;)&#x27;</span><br><span class="line">&#123; $$ = static_dispatch($1,$3,$5,$7); &#125;</span><br><span class="line">| closure_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">bininv_expr    : &#x27;~&#x27; disp_expr</span><br><span class="line">&#123; $$ = neg($2); &#125;</span><br><span class="line">| disp_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">isvoid_expr    : ISVOID bininv_expr</span><br><span class="line">&#123; $$ = isvoid($2); &#125;</span><br><span class="line">| bininv_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">muldiv_expr    : muldiv_expr &#x27;*&#x27; isvoid_expr</span><br><span class="line">&#123; $$ = mul($1,$3); &#125;</span><br><span class="line">| muldiv_expr &#x27;/&#x27; isvoid_expr</span><br><span class="line">&#123; $$ = divide($1,$3); &#125;</span><br><span class="line">| isvoid_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">addsub_expr    : addsub_expr &#x27;+&#x27; muldiv_expr</span><br><span class="line">&#123; $$ = plus($1,$3); &#125;</span><br><span class="line">| addsub_expr &#x27;-&#x27; muldiv_expr</span><br><span class="line">&#123; $$ = sub($1,$3); &#125;</span><br><span class="line">| muldiv_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">comp_expr    : addsub_expr LE addsub_expr</span><br><span class="line">&#123; $$ = leq($1,$3); &#125;</span><br><span class="line">| addsub_expr &#x27;&lt;&#x27; addsub_expr</span><br><span class="line">&#123; $$ = lt($1,$3); &#125;</span><br><span class="line">| addsub_expr &#x27;=&#x27; addsub_expr</span><br><span class="line">&#123; $$ = eq($1,$3); &#125;</span><br><span class="line">| addsub_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">loginv_expr    : NOT comp_expr</span><br><span class="line">&#123; $$ = comp($2); &#125;</span><br><span class="line">| comp_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">assign_expr    : OBJECTID ASSIGN loginv_expr</span><br><span class="line">&#123; $$ = assign($1,$3); &#125;</span><br><span class="line">| loginv_expr</span><br><span class="line">&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">let_expr    : LET OBJECTID &#x27;:&#x27; TYPEID let_rem_expr</span><br><span class="line">&#123; $$ = let($2,$4,no_expr(),$5); &#125;</span><br><span class="line">| LET OBJECTID &#x27;:&#x27; TYPEID ASSIGN expr let_rem_expr</span><br><span class="line">&#123; $$ = let($2,$4,$6,$7); &#125;</span><br><span class="line">| LET error let_rem_expr</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">let_rem_expr    : IN expr</span><br><span class="line">&#123; $$ = $2; &#125;</span><br><span class="line">| &#x27;,&#x27; OBJECTID &#x27;:&#x27; TYPEID let_rem_expr</span><br><span class="line">&#123; $$ = let($2,$4,no_expr(),$5); &#125;</span><br><span class="line">| &#x27;,&#x27; OBJECTID &#x27;:&#x27; TYPEID ASSIGN expr let_rem_expr</span><br><span class="line">&#123; $$ = let($2,$4,$6,$7); &#125;</span><br><span class="line">| &#x27;,&#x27; error let_rem_expr</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">block_expr_list    : expr &#x27;;&#x27;</span><br><span class="line">&#123; $$ = single_Expressions($1); &#125;</span><br><span class="line">| block_expr_list expr &#x27;;&#x27;</span><br><span class="line">&#123; $$ = append_Expressions($1,single_Expressions($2)); &#125;</span><br><span class="line">| block_expr_list error &#x27;;&#x27;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">aug_expr_list    : 	</span><br><span class="line">&#123; $$ = nil_Expressions(); &#125;</span><br><span class="line">| expr</span><br><span class="line">&#123; $$ = single_Expressions($1); &#125;</span><br><span class="line">| aug_expr_list &#x27;,&#x27; expr</span><br><span class="line">&#123; $$ = append_Expressions($1,single_Expressions($3)); &#125;</span><br><span class="line">| aug_expr_list &#x27;,&#x27; error</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* end of grammar */</span><br></pre></td></tr></table></figure>
<p>bison
语法中的<code>\$$</code>表示非终止符的返回属性，<code>$d</code>表示产生式中第
d 个符号的返回属性，生成 AST
结点的方法在手册以及对应的构造函数声明当中。</p>
<p>关于优先级我这里直接将优先级使用语法表示了，因此没有使用优先级定义。具体来讲，有关运算符的非终止符表示的不只是其本身，而是表示本“层级”以下的所有类型的表达式。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag"># 编译原理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/08/cs143-lexer/" rel="prev" title="Compiler -- Lexer">
                  <i class="fa fa-angle-left"></i> Compiler -- Lexer
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/17/cs143-semant/" rel="next" title="Compiler -- Semant">
                  Compiler -- Semant <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AjiL</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
